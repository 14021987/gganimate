---
title: "Getting Started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  cache = TRUE,
  gganimate.nframes = 50
)
```

*gganimate* is an extension of the *grammar of graphics*, as implemented by the
[*ggplot2*](https://ggplot2.tidyverse.org) package, that adds support for 
declaring animations using an API familiar to users of *ggplot2*.

> The following introduction assumes familiarity with *ggplot2* to the extend 
  that constructing static plots and reading standard *ggplot2* code feels
  natural. If you are new to both *ggplot2* and *gganimate* you'll benefit from
  exploring the trove of *ggplot2* documentation, tutorials, and courses 
  avaialble online first (see the 
  [*ggplot2* webpage](https://ggplot2.tidyverse.org/#learning-ggplot2) for some 
  pointers).
  
## Your First Animation
We'll jump right into our first animation. Don't worry too much about 
understanding the code, as we'll dissect it later.

```{r}
library(gganimate)

# We'll start with a static plot
p <- ggplot(iris, aes(x = Petal.Width, y = Petal.Length)) + 
  geom_point()

plot(p)
```

You go from a static plot made with *ggplot2* to an animated one, simply by 
adding on functions from *gganimate*.

```{r}
anim <- p + 
  transition_states(Species,
                    transition_length = 2,
                    state_length = 1)

anim
```

> ‚ùó `transition_states()` splits up plot data by a discrete varaible and 
  animates between the different states.

As can be seen, very few additions to the plot results in a quite complex 
animation. So what did we do to get this animation? We added a type of 
*transition*. Transitions are functions that interpret the plot data in order to
somehow distribute it over a number of frames. `transition_states()` 
specifically splits the data into subsets based on a variable in the data (here
`Species`), and calculates intermediary data states that ensures a smooth
transition between the states (something refered to as *tweening*). *gganimate*
provides a range of different transitions, but for the next couple of examples
we'll be sticking to `transition_states()` and see how we can modify the output.

### Easing
When `transition_states()` calculates intermediary data for the tweening, it 
needs to decide how the change from one value to another should progress. This
is a concept called *easing*. The default easing is *linear*, but others can be
used, potentially only targeting specific aesthetics. Setting easing is done
with the `ease_aes()` function. The first argument sets the default easing and
subsequent named arguments sets it for specific aesthetics.

```{r}
anim + 
  ease_aes('cubic-in-out') # Slow start and end for a smoother look
```

```{r}
anim + 
  ease_aes('linear', y = 'bounce-out') # Sets special ease for y aesthetic
```

### Labelling
It can be quite hard to understand an animation without any indication as to
what each time point relates to. *gganimate* solves this by providing a set of 
variables for each frame, which can be inserted into plot labels using 
[*glue*](https://glue.tidyverse.org) syntax.

```{r}
anim + 
  ggtitle('Now showing {closest_state}',
          subtitle = 'Frame {frame} of {nframes}')
```

Different transitions provide different frame variables. `closest_state` only
makes sense for `transition_states()` and is thus only avaialable when that 
transition is used.
